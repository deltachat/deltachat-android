/* Autogenerated file, do not edit manually */
package chat.delta.rpc;

import com.fasterxml.jackson.core.type.TypeReference;

import chat.delta.rpc.types.*;

public class Rpc {

  public interface Transport {
    public void call(String method, Object... params) throws RpcException;
    public <T> T callForResult(TypeReference<T> resultType, String method, Object... params) throws RpcException;
  }

  public final Transport transport;

  public Rpc(Transport transport) {
    this.transport = transport;
  }

  /* Test function. */
  public void sleep(Float delay) throws RpcException {
    transport.call("sleep", delay);
  }

  /* Checks if an email address is valid. */
  public Boolean checkEmailValidity(String email) throws RpcException {
    return transport.callForResult(new TypeReference<Boolean>(){}, "check_email_validity", email);
  }

  /* Returns general system info. */
  public java.util.Map<String, String> getSystemInfo() throws RpcException {
    return transport.callForResult(new TypeReference<java.util.Map<String, String>>(){}, "get_system_info");
  }

  /* Get the next event. */
  public Event getNextEvent() throws RpcException {
    return transport.callForResult(new TypeReference<Event>(){}, "get_next_event");
  }

  public Integer addAccount() throws RpcException {
    return transport.callForResult(new TypeReference<Integer>(){}, "add_account");
  }

  /**
   *  Imports/migrated an existing account from a database path into this account manager.
   *  Returns the ID of new account.
   */
  public Integer migrateAccount(String pathToDb) throws RpcException {
    return transport.callForResult(new TypeReference<Integer>(){}, "migrate_account", pathToDb);
  }

  public void removeAccount(Integer accountId) throws RpcException {
    transport.call("remove_account", accountId);
  }

  public java.util.List<Integer> getAllAccountIds() throws RpcException {
    return transport.callForResult(new TypeReference<java.util.List<Integer>>(){}, "get_all_account_ids");
  }

  /**
   *  Select account id for internally selected state.
   *  TODO: Likely this is deprecated as all methods take an account id now.
   */
  public void selectAccount(Integer id) throws RpcException {
    transport.call("select_account", id);
  }

  /**
   *  Get the selected account id of the internal state..
   *  TODO: Likely this is deprecated as all methods take an account id now.
   */
  public Integer getSelectedAccountId() throws RpcException {
    return transport.callForResult(new TypeReference<Integer>(){}, "get_selected_account_id");
  }

  /* Get a list of all configured accounts. */
  public java.util.List<Account> getAllAccounts() throws RpcException {
    return transport.callForResult(new TypeReference<java.util.List<Account>>(){}, "get_all_accounts");
  }

  /* Starts background tasks for all accounts. */
  public void startIoForAllAccounts() throws RpcException {
    transport.call("start_io_for_all_accounts");
  }

  /* Stops background tasks for all accounts. */
  public void stopIoForAllAccounts() throws RpcException {
    transport.call("stop_io_for_all_accounts");
  }

  /**
   *  Performs a background fetch for all accounts in parallel with a timeout.
   *
   *  The `AccountsBackgroundFetchDone` event is emitted at the end even in case of timeout.
   *  Process all events until you get this one and you can safely return to the background
   *  without forgetting to create notifications caused by timing race conditions.
   */
  public void accountsBackgroundFetch(Float timeoutInSeconds) throws RpcException {
    transport.call("accounts_background_fetch", timeoutInSeconds);
  }

  /* Starts background tasks for a single account. */
  public void startIo(Integer accountId) throws RpcException {
    transport.call("start_io", accountId);
  }

  /* Stops background tasks for a single account. */
  public void stopIo(Integer accountId) throws RpcException {
    transport.call("stop_io", accountId);
  }

  /* Get top-level info for an account. */
  public Account getAccountInfo(Integer accountId) throws RpcException {
    return transport.callForResult(new TypeReference<Account>(){}, "get_account_info", accountId);
  }

  /* Get the combined filesize of an account in bytes */
  public Integer getAccountFileSize(Integer accountId) throws RpcException {
    return transport.callForResult(new TypeReference<Integer>(){}, "get_account_file_size", accountId);
  }

  /**
   *  Returns provider for the given domain.
   *
   *  This function looks up domain in offline database.
   *
   *  For compatibility, email address can be passed to this function
   *  instead of the domain.
   */
  public ProviderInfo getProviderInfo(Integer accountId, String email) throws RpcException {
    return transport.callForResult(new TypeReference<ProviderInfo>(){}, "get_provider_info", accountId, email);
  }

  /* Checks if the context is already configured. */
  public Boolean isConfigured(Integer accountId) throws RpcException {
    return transport.callForResult(new TypeReference<Boolean>(){}, "is_configured", accountId);
  }

  /* Get system info for an account. */
  public java.util.Map<String, String> getInfo(Integer accountId) throws RpcException {
    return transport.callForResult(new TypeReference<java.util.Map<String, String>>(){}, "get_info", accountId);
  }

  public String getBlobDir(Integer accountId) throws RpcException {
    return transport.callForResult(new TypeReference<String>(){}, "get_blob_dir", accountId);
  }

  public Integer draftSelfReport(Integer accountId) throws RpcException {
    return transport.callForResult(new TypeReference<Integer>(){}, "draft_self_report", accountId);
  }

  /* Sets the given configuration key. */
  public void setConfig(Integer accountId, String key, String value) throws RpcException {
    transport.call("set_config", accountId, key, value);
  }

  /* Updates a batch of configuration values. */
  public void batchSetConfig(Integer accountId, java.util.Map<String, String> config) throws RpcException {
    transport.call("batch_set_config", accountId, config);
  }

  /**
   *  Set configuration values from a QR code. (technically from the URI that is stored in the qrcode)
   *  Before this function is called, `checkQr()` should confirm the type of the
   *  QR code is `account` or `webrtcInstance`.
   *
   *  Internally, the function will call dc_set_config() with the appropriate keys,
   */
  public void setConfigFromQr(Integer accountId, String qrContent) throws RpcException {
    transport.call("set_config_from_qr", accountId, qrContent);
  }

  public Qr checkQr(Integer accountId, String qrContent) throws RpcException {
    return transport.callForResult(new TypeReference<Qr>(){}, "check_qr", accountId, qrContent);
  }

  /* Returns configuration value for the given key. */
  public String getConfig(Integer accountId, String key) throws RpcException {
    return transport.callForResult(new TypeReference<String>(){}, "get_config", accountId, key);
  }

  public java.util.Map<String, String> batchGetConfig(Integer accountId, java.util.List<String> keys) throws RpcException {
    return transport.callForResult(new TypeReference<java.util.Map<String, String>>(){}, "batch_get_config", accountId, keys);
  }

  public void setStockStrings(java.util.Map<String, String> strings) throws RpcException {
    transport.call("set_stock_strings", strings);
  }

  /**
   *  Configures this account with the currently set parameters.
   *  Setup the credential config before calling this.
   */
  public void configure(Integer accountId) throws RpcException {
    transport.call("configure", accountId);
  }

  /* Signal an ongoing process to stop. */
  public void stopOngoingProcess(Integer accountId) throws RpcException {
    transport.call("stop_ongoing_process", accountId);
  }

  public void exportSelfKeys(Integer accountId, String path, String passphrase) throws RpcException {
    transport.call("export_self_keys", accountId, path, passphrase);
  }

  public void importSelfKeys(Integer accountId, String path, String passphrase) throws RpcException {
    transport.call("import_self_keys", accountId, path, passphrase);
  }

  /**
   *  Returns the message IDs of all _fresh_ messages of any chat.
   *  Typically used for implementing notification summaries
   *  or badge counters e.g. on the app icon.
   *  The list is already sorted and starts with the most recent fresh message.
   *
   *  Messages belonging to muted chats or to the contact requests are not returned;
   *  these messages should not be notified
   *  and also badge counters should not include these messages.
   *
   *  To get the number of fresh messages for a single chat, muted or not,
   *  use `get_fresh_msg_cnt()`.
   */
  public java.util.List<Integer> getFreshMsgs(Integer accountId) throws RpcException {
    return transport.callForResult(new TypeReference<java.util.List<Integer>>(){}, "get_fresh_msgs", accountId);
  }

  /**
   *  Get the number of _fresh_ messages in a chat.
   *  Typically used to implement a badge with a number in the chatlist.
   *
   *  If the specified chat is muted,
   *  the UI should show the badge counter "less obtrusive",
   *  e.g. using "gray" instead of "red" color.
   */
  public Integer getFreshMsgCnt(Integer accountId, Integer chatId) throws RpcException {
    return transport.callForResult(new TypeReference<Integer>(){}, "get_fresh_msg_cnt", accountId, chatId);
  }

  /**
   *  Gets messages to be processed by the bot and returns their IDs.
   *
   *  Only messages with database ID higher than `last_msg_id` config value
   *  are returned. After processing the messages, the bot should
   *  update `last_msg_id` by calling [`markseen_msgs`]
   *  or manually updating the value to avoid getting already
   *  processed messages.
   *
   *  [`markseen_msgs`]: Self::markseen_msgs
   */
  public java.util.List<Integer> getNextMsgs(Integer accountId) throws RpcException {
    return transport.callForResult(new TypeReference<java.util.List<Integer>>(){}, "get_next_msgs", accountId);
  }

  /**
   *  Waits for messages to be processed by the bot and returns their IDs.
   *
   *  This function is similar to [`get_next_msgs`],
   *  but waits for internal new message notification before returning.
   *  New message notification is sent when new message is added to the database,
   *  on initialization, when I/O is started and when I/O is stopped.
   *  This allows bots to use `wait_next_msgs` in a loop to process
   *  old messages after initialization and during the bot runtime.
   *  To shutdown the bot, stopping I/O can be used to interrupt
   *  pending or next `wait_next_msgs` call.
   *
   *  [`get_next_msgs`]: Self::get_next_msgs
   */
  public java.util.List<Integer> waitNextMsgs(Integer accountId) throws RpcException {
    return transport.callForResult(new TypeReference<java.util.List<Integer>>(){}, "wait_next_msgs", accountId);
  }

  /**
   *  Estimate the number of messages that will be deleted
   *  by the set_config()-options `delete_device_after` or `delete_server_after`.
   *  This is typically used to show the estimated impact to the user
   *  before actually enabling deletion of old messages.
   */
  public Integer estimateAutoDeletionCount(Integer accountId, Boolean fromServer, Integer seconds) throws RpcException {
    return transport.callForResult(new TypeReference<Integer>(){}, "estimate_auto_deletion_count", accountId, fromServer, seconds);
  }

  public String initiateAutocryptKeyTransfer(Integer accountId) throws RpcException {
    return transport.callForResult(new TypeReference<String>(){}, "initiate_autocrypt_key_transfer", accountId);
  }

  public void continueAutocryptKeyTransfer(Integer accountId, Integer messageId, String setupCode) throws RpcException {
    transport.call("continue_autocrypt_key_transfer", accountId, messageId, setupCode);
  }

  public java.util.List<Integer> getChatlistEntries(Integer accountId, Integer listFlags, String queryString, Integer queryContactId) throws RpcException {
    return transport.callForResult(new TypeReference<java.util.List<Integer>>(){}, "get_chatlist_entries", accountId, listFlags, queryString, queryContactId);
  }

  /**
   *  Returns chats similar to the given one.
   *
   *  Experimental API, subject to change without notice.
   */
  public java.util.List<Integer> getSimilarChatIds(Integer accountId, Integer chatId) throws RpcException {
    return transport.callForResult(new TypeReference<java.util.List<Integer>>(){}, "get_similar_chat_ids", accountId, chatId);
  }

  public java.util.Map<String, ChatListItemFetchResult> getChatlistItemsByEntries(Integer accountId, java.util.List<Integer> entries) throws RpcException {
    return transport.callForResult(new TypeReference<java.util.Map<String, ChatListItemFetchResult>>(){}, "get_chatlist_items_by_entries", accountId, entries);
  }

  public FullChat getFullChatById(Integer accountId, Integer chatId) throws RpcException {
    return transport.callForResult(new TypeReference<FullChat>(){}, "get_full_chat_by_id", accountId, chatId);
  }

  /**
   *  get basic info about a chat,
   *  use chatlist_get_full_chat_by_id() instead if you need more information
   */
  public BasicChat getBasicChatInfo(Integer accountId, Integer chatId) throws RpcException {
    return transport.callForResult(new TypeReference<BasicChat>(){}, "get_basic_chat_info", accountId, chatId);
  }

  public void acceptChat(Integer accountId, Integer chatId) throws RpcException {
    transport.call("accept_chat", accountId, chatId);
  }

  public void blockChat(Integer accountId, Integer chatId) throws RpcException {
    transport.call("block_chat", accountId, chatId);
  }

  /**
   *  Delete a chat.
   *
   *  Messages are deleted from the device and the chat database entry is deleted.
   *  After that, the event #DC_EVENT_MSGS_CHANGED is posted.
   *
   *  Things that are _not done_ implicitly:
   *
   *  - Messages are **not deleted from the server**.
   *  - The chat or the contact is **not blocked**, so new messages from the user/the group may appear as a contact request
   *    and the user may create the chat again.
   *  - **Groups are not left** - this would
   *    be unexpected as (1) deleting a normal chat also does not prevent new mails
   *    from arriving, (2) leaving a group requires sending a message to
   *    all group members - especially for groups not used for a longer time, this is
   *    really unexpected when deletion results in contacting all members again,
   *    (3) only leaving groups is also a valid usecase.
   *
   *  To leave a chat explicitly, use leave_group()
   */
  public void deleteChat(Integer accountId, Integer chatId) throws RpcException {
    transport.call("delete_chat", accountId, chatId);
  }

  /**
   *  Get encryption info for a chat.
   *  Get a multi-line encryption info, containing encryption preferences of all members.
   *  Can be used to find out why messages sent to group are not encrypted.
   *
   *  returns Multi-line text
   */
  public String getChatEncryptionInfo(Integer accountId, Integer chatId) throws RpcException {
    return transport.callForResult(new TypeReference<String>(){}, "get_chat_encryption_info", accountId, chatId);
  }

  /**
   *  Get QR code (text and SVG) that will offer an Setup-Contact or Verified-Group invitation.
   *  The QR code is compatible to the OPENPGP4FPR format
   *  so that a basic fingerprint comparison also works e.g. with OpenKeychain.
   *
   *  The scanning device will pass the scanned content to `checkQr()` then;
   *  if `checkQr()` returns `askVerifyContact` or `askVerifyGroup`
   *  an out-of-band-verification can be joined using `secure_join()`
   *
   *  chat_id: If set to a group-chat-id,
   *      the Verified-Group-Invite protocol is offered in the QR code;
   *      works for protected groups as well as for normal groups.
   *      If not set, the Setup-Contact protocol is offered in the QR code.
   *      See https://securejoin.delta.chat/ for details about both protocols.
   *
   *  return format: `[code, svg]`
   */
  public Pair<String, String> getChatSecurejoinQrCodeSvg(Integer accountId, Integer chatId) throws RpcException {
    return transport.callForResult(new TypeReference<Pair<String, String>>(){}, "get_chat_securejoin_qr_code_svg", accountId, chatId);
  }

  /**
   *  Continue a Setup-Contact or Verified-Group-Invite protocol
   *  started on another device with `get_chat_securejoin_qr_code_svg()`.
   *  This function is typically called when `check_qr()` returns
   *  type=AskVerifyContact or type=AskVerifyGroup.
   *
   *  The function returns immediately and the handshake runs in background,
   *  sending and receiving several messages.
   *  During the handshake, info messages are added to the chat,
   *  showing progress, success or errors.
   *
   *  Subsequent calls of `secure_join()` will abort previous, unfinished handshakes.
   *
   *  See https://securejoin.delta.chat/ for details about both protocols.
   *
   *  **qr**: The text of the scanned QR code. Typically, the same string as given
   *      to `check_qr()`.
   *
   *  **returns**: The chat ID of the joined chat, the UI may redirect to the this chat.
   *          A returned chat ID does not guarantee that the chat is protected or the belonging contact is verified.
   *
   */
  public Integer secureJoin(Integer accountId, String qr) throws RpcException {
    return transport.callForResult(new TypeReference<Integer>(){}, "secure_join", accountId, qr);
  }

  public void leaveGroup(Integer accountId, Integer chatId) throws RpcException {
    transport.call("leave_group", accountId, chatId);
  }

  /**
   *  Remove a member from a group.
   *
   *  If the group is already _promoted_ (any message was sent to the group),
   *  all group members are informed by a special status message that is sent automatically by this function.
   *
   *  Sends out #DC_EVENT_CHAT_MODIFIED and #DC_EVENT_MSGS_CHANGED if a status message was sent.
   */
  public void removeContactFromChat(Integer accountId, Integer chatId, Integer contactId) throws RpcException {
    transport.call("remove_contact_from_chat", accountId, chatId, contactId);
  }

  /**
   *  Add a member to a group.
   *
   *  If the group is already _promoted_ (any message was sent to the group),
   *  all group members are informed by a special status message that is sent automatically by this function.
   *
   *  If the group has group protection enabled, only verified contacts can be added to the group.
   *
   *  Sends out #DC_EVENT_CHAT_MODIFIED and #DC_EVENT_MSGS_CHANGED if a status message was sent.
   */
  public void addContactToChat(Integer accountId, Integer chatId, Integer contactId) throws RpcException {
    transport.call("add_contact_to_chat", accountId, chatId, contactId);
  }

  /**
   *  Get the contact IDs belonging to a chat.
   *
   *  - for normal chats, the function always returns exactly one contact,
   *    DC_CONTACT_ID_SELF is returned only for SELF-chats.
   *
   *  - for group chats all members are returned, DC_CONTACT_ID_SELF is returned
   *    explicitly as it may happen that oneself gets removed from a still existing
   *    group
   *
   *  - for broadcasts, all recipients are returned, DC_CONTACT_ID_SELF is not included
   *
   *  - for mailing lists, the behavior is not documented currently, we will decide on that later.
   *    for now, the UI should not show the list for mailing lists.
   *    (we do not know all members and there is not always a global mailing list address,
   *    so we could return only SELF or the known members; this is not decided yet)
   */
  public java.util.List<Integer> getChatContacts(Integer accountId, Integer chatId) throws RpcException {
    return transport.callForResult(new TypeReference<java.util.List<Integer>>(){}, "get_chat_contacts", accountId, chatId);
  }

  /**
   *  Create a new group chat.
   *
   *  After creation,
   *  the group has one member with the ID DC_CONTACT_ID_SELF
   *  and is in _unpromoted_ state.
   *  This means, you can add or remove members, change the name,
   *  the group image and so on without messages being sent to all group members.
   *
   *  This changes as soon as the first message is sent to the group members
   *  and the group becomes _promoted_.
   *  After that, all changes are synced with all group members
   *  by sending status message.
   *
   *  To check, if a chat is still unpromoted, you can look at the `is_unpromoted` property of `BasicChat` or `FullChat`.
   *  This may be useful if you want to show some help for just created groups.
   *
   *  @param protect If set to 1 the function creates group with protection initially enabled.
   *      Only verified members are allowed in these groups
   *      and end-to-end-encryption is always enabled.
   */
  public Integer createGroupChat(Integer accountId, String name, Boolean protect) throws RpcException {
    return transport.callForResult(new TypeReference<Integer>(){}, "create_group_chat", accountId, name, protect);
  }

  /**
   *  Create a new broadcast list.
   *
   *  Broadcast lists are similar to groups on the sending device,
   *  however, recipients get the messages in a read-only chat
   *  and will see who the other members are.
   *
   *  For historical reasons, this function does not take a name directly,
   *  instead you have to set the name using dc_set_chat_name()
   *  after creating the broadcast list.
   */
  public Integer createBroadcastList(Integer accountId) throws RpcException {
    return transport.callForResult(new TypeReference<Integer>(){}, "create_broadcast_list", accountId);
  }

  /**
   *  Set group name.
   *
   *  If the group is already _promoted_ (any message was sent to the group),
   *  all group members are informed by a special status message that is sent automatically by this function.
   *
   *  Sends out #DC_EVENT_CHAT_MODIFIED and #DC_EVENT_MSGS_CHANGED if a status message was sent.
   */
  public void setChatName(Integer accountId, Integer chatId, String newName) throws RpcException {
    transport.call("set_chat_name", accountId, chatId, newName);
  }

  /**
   *  Set group profile image.
   *
   *  If the group is already _promoted_ (any message was sent to the group),
   *  all group members are informed by a special status message that is sent automatically by this function.
   *
   *  Sends out #DC_EVENT_CHAT_MODIFIED and #DC_EVENT_MSGS_CHANGED if a status message was sent.
   *
   *  To find out the profile image of a chat, use dc_chat_get_profile_image()
   *
   *  @param image_path Full path of the image to use as the group image. The image will immediately be copied to the
   *      `blobdir`; the original image will not be needed anymore.
   *       If you pass null here, the group image is deleted (for promoted groups, all members are informed about
   *       this change anyway).
   */
  public void setChatProfileImage(Integer accountId, Integer chatId, String imagePath) throws RpcException {
    transport.call("set_chat_profile_image", accountId, chatId, imagePath);
  }

  public void setChatVisibility(Integer accountId, Integer chatId, ChatVisibility visibility) throws RpcException {
    transport.call("set_chat_visibility", accountId, chatId, visibility);
  }

  public void setChatEphemeralTimer(Integer accountId, Integer chatId, Integer timer) throws RpcException {
    transport.call("set_chat_ephemeral_timer", accountId, chatId, timer);
  }

  public Integer getChatEphemeralTimer(Integer accountId, Integer chatId) throws RpcException {
    return transport.callForResult(new TypeReference<Integer>(){}, "get_chat_ephemeral_timer", accountId, chatId);
  }

  /**
   *  Add a message to the device-chat.
   *  Device-messages usually contain update information
   *  and some hints that are added during the program runs, multi-device etc.
   *  The device-message may be defined by a label;
   *  if a message with the same label was added or skipped before,
   *  the message is not added again, even if the message was deleted in between.
   *  If needed, the device-chat is created before.
   *
   *  Sends the `MsgsChanged` event on success.
   *
   *  Setting msg to None will prevent the device message with this label from being added in the future.
   */
  public Integer addDeviceMessage(Integer accountId, String label, MessageData msg) throws RpcException {
    return transport.callForResult(new TypeReference<Integer>(){}, "add_device_message", accountId, label, msg);
  }

  /**
   *   Mark all messages in a chat as _noticed_.
   *   _Noticed_ messages are no longer _fresh_ and do not count as being unseen
   *   but are still waiting for being marked as "seen" using markseen_msgs()
   *   (IMAP/MDNs is not done for noticed messages).
   *
   *   Calling this function usually results in the event #DC_EVENT_MSGS_NOTICED.
   *   See also markseen_msgs().
   */
  public void marknoticedChat(Integer accountId, Integer chatId) throws RpcException {
    transport.call("marknoticed_chat", accountId, chatId);
  }

  public Integer getFirstUnreadMessageOfChat(Integer accountId, Integer chatId) throws RpcException {
    return transport.callForResult(new TypeReference<Integer>(){}, "get_first_unread_message_of_chat", accountId, chatId);
  }

  /**
   *  Set mute duration of a chat.
   *
   *  The UI can then call is_chat_muted() when receiving a new message
   *  to decide whether it should trigger an notification.
   *
   *  Muted chats should not sound or vibrate
   *  and should not show a visual notification in the system area.
   *  Moreover, muted chats should be excluded from global badge counter
   *  (get_fresh_msgs() skips muted chats therefore)
   *  and the in-app, per-chat badge counter should use a less obtrusive color.
   *
   *  Sends out #DC_EVENT_CHAT_MODIFIED.
   */
  public void setChatMuteDuration(Integer accountId, Integer chatId, MuteDuration duration) throws RpcException {
    transport.call("set_chat_mute_duration", accountId, chatId, duration);
  }

  /**
   *  Check whether the chat is currently muted (can be changed by set_chat_mute_duration()).
   *
   *  This is available as a standalone function outside of fullchat, because it might be only needed for notification
   */
  public Boolean isChatMuted(Integer accountId, Integer chatId) throws RpcException {
    return transport.callForResult(new TypeReference<Boolean>(){}, "is_chat_muted", accountId, chatId);
  }

  /**
   *  Mark messages as presented to the user.
   *  Typically, UIs call this function on scrolling through the message list,
   *  when the messages are presented at least for a little moment.
   *  The concrete action depends on the type of the chat and on the users settings
   *  (dc_msgs_presented() may be a better name therefore, but well. :)
   *
   *  - For normal chats, the IMAP state is updated, MDN is sent
   *    (if set_config()-options `mdns_enabled` is set)
   *    and the internal state is changed to @ref DC_STATE_IN_SEEN to reflect these actions.
   *
   *  - For contact requests, no IMAP or MDNs is done
   *    and the internal state is not changed therefore.
   *    See also marknoticed_chat().
   *
   *  Moreover, timer is started for incoming ephemeral messages.
   *  This also happens for contact requests chats.
   *
   *  This function updates `last_msg_id` configuration value
   *  to the maximum of the current value and IDs passed to this function.
   *  Bots which mark messages as seen can rely on this side effect
   *  to avoid updating `last_msg_id` value manually.
   *
   *  One #DC_EVENT_MSGS_NOTICED event is emitted per modified chat.
   */
  public void markseenMsgs(Integer accountId, java.util.List<Integer> msgIds) throws RpcException {
    transport.call("markseen_msgs", accountId, msgIds);
  }

  public java.util.List<Integer> getMessageIds(Integer accountId, Integer chatId, Boolean infoOnly, Boolean addDaymarker) throws RpcException {
    return transport.callForResult(new TypeReference<java.util.List<Integer>>(){}, "get_message_ids", accountId, chatId, infoOnly, addDaymarker);
  }

  public java.util.List<MessageListItem> getMessageListItems(Integer accountId, Integer chatId, Boolean infoOnly, Boolean addDaymarker) throws RpcException {
    return transport.callForResult(new TypeReference<java.util.List<MessageListItem>>(){}, "get_message_list_items", accountId, chatId, infoOnly, addDaymarker);
  }

  public Message getMessage(Integer accountId, Integer msgId) throws RpcException {
    return transport.callForResult(new TypeReference<Message>(){}, "get_message", accountId, msgId);
  }

  public String getMessageHtml(Integer accountId, Integer messageId) throws RpcException {
    return transport.callForResult(new TypeReference<String>(){}, "get_message_html", accountId, messageId);
  }

  /**
   *  get multiple messages in one call,
   *  if loading one message fails the error is stored in the result object in it's place.
   *
   *  this is the batch variant of [get_message]
   */
  public java.util.Map<String, MessageLoadResult> getMessages(Integer accountId, java.util.List<Integer> messageIds) throws RpcException {
    return transport.callForResult(new TypeReference<java.util.Map<String, MessageLoadResult>>(){}, "get_messages", accountId, messageIds);
  }

  /* Fetch info desktop needs for creating a notification for a message */
  public MessageNotificationInfo getMessageNotificationInfo(Integer accountId, Integer messageId) throws RpcException {
    return transport.callForResult(new TypeReference<MessageNotificationInfo>(){}, "get_message_notification_info", accountId, messageId);
  }

  /**
   *  Delete messages. The messages are deleted on the current device and
   *  on the IMAP server.
   */
  public void deleteMessages(Integer accountId, java.util.List<Integer> messageIds) throws RpcException {
    transport.call("delete_messages", accountId, messageIds);
  }

  /**
   *  Get an informational text for a single message. The text is multiline and may
   *  contain e.g. the raw text of the message.
   *
   *  The max. text returned is typically longer (about 100000 characters) than the
   *  max. text returned by dc_msg_get_text() (about 30000 characters).
   */
  public String getMessageInfo(Integer accountId, Integer messageId) throws RpcException {
    return transport.callForResult(new TypeReference<String>(){}, "get_message_info", accountId, messageId);
  }

  /* Returns additional information for single message. */
  public MessageInfo getMessageInfoObject(Integer accountId, Integer messageId) throws RpcException {
    return transport.callForResult(new TypeReference<MessageInfo>(){}, "get_message_info_object", accountId, messageId);
  }

  /* Returns contacts that sent read receipts and the time of reading. */
  public java.util.List<MessageReadReceipt> getMessageReadReceipts(Integer accountId, Integer messageId) throws RpcException {
    return transport.callForResult(new TypeReference<java.util.List<MessageReadReceipt>>(){}, "get_message_read_receipts", accountId, messageId);
  }

  /**
   *  Asks the core to start downloading a message fully.
   *  This function is typically called when the user hits the "Download" button
   *  that is shown by the UI in case `download_state` is `'Available'` or `'Failure'`
   *
   *  On success, the @ref DC_MSG "view type of the message" may change
   *  or the message may be replaced completely by one or more messages with other message IDs.
   *  That may happen e.g. in cases where the message was encrypted
   *  and the type could not be determined without fully downloading.
   *  Downloaded content can be accessed as usual after download.
   *
   *  To reflect these changes a @ref DC_EVENT_MSGS_CHANGED event will be emitted.
   */
  public void downloadFullMessage(Integer accountId, Integer messageId) throws RpcException {
    transport.call("download_full_message", accountId, messageId);
  }

  /**
   *  Search messages containing the given query string.
   *  Searching can be done globally (chat_id=None) or in a specified chat only (chat_id set).
   *
   *  Global search results are typically displayed using dc_msg_get_summary(), chat
   *  search results may just highlight the corresponding messages and present a
   *  prev/next button.
   *
   *  For the global search, the result is limited to 1000 messages,
   *  this allows an incremental search done fast.
   *  So, when getting exactly 1000 messages, the result actually may be truncated;
   *  the UIs may display sth. like "1000+ messages found" in this case.
   *  The chat search (if chat_id is set) is not limited.
   */
  public java.util.List<Integer> searchMessages(Integer accountId, String query, Integer chatId) throws RpcException {
    return transport.callForResult(new TypeReference<java.util.List<Integer>>(){}, "search_messages", accountId, query, chatId);
  }

  public java.util.Map<String, MessageSearchResult> messageIdsToSearchResults(Integer accountId, java.util.List<Integer> messageIds) throws RpcException {
    return transport.callForResult(new TypeReference<java.util.Map<String, MessageSearchResult>>(){}, "message_ids_to_search_results", accountId, messageIds);
  }

  /* Get a single contact options by ID. */
  public Contact getContact(Integer accountId, Integer contactId) throws RpcException {
    return transport.callForResult(new TypeReference<Contact>(){}, "get_contact", accountId, contactId);
  }

  /**
   *  Add a single contact as a result of an explicit user action.
   *
   *  Returns contact id of the created or existing contact
   */
  public Integer createContact(Integer accountId, String email, String name) throws RpcException {
    return transport.callForResult(new TypeReference<Integer>(){}, "create_contact", accountId, email, name);
  }

  /* Returns contact id of the created or existing DM chat with that contact */
  public Integer createChatByContactId(Integer accountId, Integer contactId) throws RpcException {
    return transport.callForResult(new TypeReference<Integer>(){}, "create_chat_by_contact_id", accountId, contactId);
  }

  public void blockContact(Integer accountId, Integer contactId) throws RpcException {
    transport.call("block_contact", accountId, contactId);
  }

  public void unblockContact(Integer accountId, Integer contactId) throws RpcException {
    transport.call("unblock_contact", accountId, contactId);
  }

  public java.util.List<Contact> getBlockedContacts(Integer accountId) throws RpcException {
    return transport.callForResult(new TypeReference<java.util.List<Contact>>(){}, "get_blocked_contacts", accountId);
  }

  public java.util.List<Integer> getContactIds(Integer accountId, Integer listFlags, String query) throws RpcException {
    return transport.callForResult(new TypeReference<java.util.List<Integer>>(){}, "get_contact_ids", accountId, listFlags, query);
  }

  /**
   *  Get a list of contacts.
   *  (formerly called getContacts2 in desktop)
   */
  public java.util.List<Contact> getContacts(Integer accountId, Integer listFlags, String query) throws RpcException {
    return transport.callForResult(new TypeReference<java.util.List<Contact>>(){}, "get_contacts", accountId, listFlags, query);
  }

  public java.util.Map<String, Contact> getContactsByIds(Integer accountId, java.util.List<Integer> ids) throws RpcException {
    return transport.callForResult(new TypeReference<java.util.Map<String, Contact>>(){}, "get_contacts_by_ids", accountId, ids);
  }

  public void deleteContact(Integer accountId, Integer contactId) throws RpcException {
    transport.call("delete_contact", accountId, contactId);
  }

  public void changeContactName(Integer accountId, Integer contactId, String name) throws RpcException {
    transport.call("change_contact_name", accountId, contactId, name);
  }

  /**
   *  Get encryption info for a contact.
   *  Get a multi-line encryption info, containing your fingerprint and the
   *  fingerprint of the contact, used e.g. to compare the fingerprints for a simple out-of-band verification.
   */
  public String getContactEncryptionInfo(Integer accountId, Integer contactId) throws RpcException {
    return transport.callForResult(new TypeReference<String>(){}, "get_contact_encryption_info", accountId, contactId);
  }

  /**
   *  Check if an e-mail address belongs to a known and unblocked contact.
   *  To get a list of all known and unblocked contacts, use contacts_get_contacts().
   *
   *  To validate an e-mail address independently of the contact database
   *  use check_email_validity().
   */
  public Integer lookupContactIdByAddr(Integer accountId, String addr) throws RpcException {
    return transport.callForResult(new TypeReference<Integer>(){}, "lookup_contact_id_by_addr", accountId, addr);
  }

  /* Parses a vCard file located at the given path. Returns contacts in their original order. */
  public java.util.List<VcardContact> parseVcard(String path) throws RpcException {
    return transport.callForResult(new TypeReference<java.util.List<VcardContact>>(){}, "parse_vcard", path);
  }

  /**
   *  Imports contacts from a vCard file located at the given path.
   *
   *  Returns the ids of created/modified contacts in the order they appear in the vCard.
   */
  public java.util.List<Integer> importVcard(Integer accountId, String path) throws RpcException {
    return transport.callForResult(new TypeReference<java.util.List<Integer>>(){}, "import_vcard", accountId, path);
  }

  /* Returns a vCard containing contacts with the given ids. */
  public String makeVcard(Integer accountId, java.util.List<Integer> contacts) throws RpcException {
    return transport.callForResult(new TypeReference<String>(){}, "make_vcard", accountId, contacts);
  }

  /**
   *  Returns the [`ChatId`] for the 1:1 chat with `contact_id` if it exists.
   *
   *  If it does not exist, `None` is returned.
   */
  public Integer getChatIdByContactId(Integer accountId, Integer contactId) throws RpcException {
    return transport.callForResult(new TypeReference<Integer>(){}, "get_chat_id_by_contact_id", accountId, contactId);
  }

  /**
   *  Returns all message IDs of the given types in a chat.
   *  Typically used to show a gallery.
   *
   *  The list is already sorted and starts with the oldest message.
   *  Clients should not try to re-sort the list as this would be an expensive action
   *  and would result in inconsistencies between clients.
   *
   *  Setting `chat_id` to `None` (`null` in typescript) means get messages with media
   *  from any chat of the currently used account.
   */
  public java.util.List<Integer> getChatMedia(Integer accountId, Integer chatId, Viewtype messageType, Viewtype orMessageType2, Viewtype orMessageType3) throws RpcException {
    return transport.callForResult(new TypeReference<java.util.List<Integer>>(){}, "get_chat_media", accountId, chatId, messageType, orMessageType2, orMessageType3);
  }

  /**
   *  Search next/previous message based on a given message and a list of types.
   *  Typically used to implement the "next" and "previous" buttons
   *  in a gallery or in a media player.
   *
   *  one combined call for getting chat::get_next_media for both directions
   *  the manual chat::get_next_media in only one direction is not exposed by the jsonrpc yet
   *
   *  Deprecated 2023-10-03, use `get_chat_media` method
   *  and navigate the returned array instead.
   */
  public Pair<Integer, Integer> getNeighboringChatMedia(Integer accountId, Integer msgId, Viewtype messageType, Viewtype orMessageType2, Viewtype orMessageType3) throws RpcException {
    return transport.callForResult(new TypeReference<Pair<Integer, Integer>>(){}, "get_neighboring_chat_media", accountId, msgId, messageType, orMessageType2, orMessageType3);
  }

  public void exportBackup(Integer accountId, String destination, String passphrase) throws RpcException {
    transport.call("export_backup", accountId, destination, passphrase);
  }

  public void importBackup(Integer accountId, String path, String passphrase) throws RpcException {
    transport.call("import_backup", accountId, path, passphrase);
  }

  /**
   *  Offers a backup for remote devices to retrieve.
   *
   *  Can be cancelled by stopping the ongoing process.  Success or failure can be tracked
   *  via the `ImexProgress` event which should either reach `1000` for success or `0` for
   *  failure.
   *
   *  This **stops IO** while it is running.
   *
   *  Returns once a remote device has retrieved the backup, or is cancelled.
   */
  public void provideBackup(Integer accountId) throws RpcException {
    transport.call("provide_backup", accountId);
  }

  /**
   *  Returns the text of the QR code for the running [`CommandApi::provide_backup`].
   *
   *  This QR code text can be used in [`CommandApi::get_backup`] on a second device to
   *  retrieve the backup and setup this second device.
   *
   *  This call will block until the QR code is ready,
   *  even if there is no concurrent call to [`CommandApi::provide_backup`],
   *  but will fail after 10 seconds to avoid deadlocks.
   */
  public String getBackupQr(Integer accountId) throws RpcException {
    return transport.callForResult(new TypeReference<String>(){}, "get_backup_qr", accountId);
  }

  /**
   *  Returns the rendered QR code for the running [`CommandApi::provide_backup`].
   *
   *  This QR code can be used in [`CommandApi::get_backup`] on a second device to
   *  retrieve the backup and setup this second device.
   *
   *  This call will block until the QR code is ready,
   *  even if there is no concurrent call to [`CommandApi::provide_backup`],
   *  but will fail after 10 seconds to avoid deadlocks.
   *
   *  Returns the QR code rendered as an SVG image.
   */
  public String getBackupQrSvg(Integer accountId) throws RpcException {
    return transport.callForResult(new TypeReference<String>(){}, "get_backup_qr_svg", accountId);
  }

  /**
   *  Gets a backup from a remote provider.
   *
   *  This retrieves the backup from a remote device over the network and imports it into
   *  the current device.
   *
   *  Can be cancelled by stopping the ongoing process.
   *
   *  Do not forget to call start_io on the account after a successful import,
   *  otherwise it will not connect to the email server.
   */
  public void getBackup(Integer accountId, String qrText) throws RpcException {
    transport.call("get_backup", accountId, qrText);
  }

  /**
   *  Indicate that the network likely has come back.
   *  or just that the network conditions might have changed
   */
  public void maybeNetwork() throws RpcException {
    transport.call("maybe_network");
  }

  /**
   *  Get the current connectivity, i.e. whether the device is connected to the IMAP server.
   *  One of:
   *  - DC_CONNECTIVITY_NOT_CONNECTED (1000-1999): Show e.g. the string "Not connected" or a red dot
   *  - DC_CONNECTIVITY_CONNECTING (2000-2999): Show e.g. the string "Connecting…" or a yellow dot
   *  - DC_CONNECTIVITY_WORKING (3000-3999): Show e.g. the string "Getting new messages" or a spinning wheel
   *  - DC_CONNECTIVITY_CONNECTED (>=4000): Show e.g. the string "Connected" or a green dot
   *
   *  We don't use exact values but ranges here so that we can split up
   *  states into multiple states in the future.
   *
   *  Meant as a rough overview that can be shown
   *  e.g. in the title of the main screen.
   *
   *  If the connectivity changes, a #DC_EVENT_CONNECTIVITY_CHANGED will be emitted.
   */
  public Integer getConnectivity(Integer accountId) throws RpcException {
    return transport.callForResult(new TypeReference<Integer>(){}, "get_connectivity", accountId);
  }

  /**
   *  Get an overview of the current connectivity, and possibly more statistics.
   *  Meant to give the user more insight about the current status than
   *  the basic connectivity info returned by get_connectivity(); show this
   *  e.g., if the user taps on said basic connectivity info.
   *
   *  If this page changes, a #DC_EVENT_CONNECTIVITY_CHANGED will be emitted.
   *
   *  This comes as an HTML from the core so that we can easily improve it
   *  and the improvement instantly reaches all UIs.
   */
  public String getConnectivityHtml(Integer accountId) throws RpcException {
    return transport.callForResult(new TypeReference<String>(){}, "get_connectivity_html", accountId);
  }

  public java.util.List<Location> getLocations(Integer accountId, Integer chatId, Integer contactId, Integer timestampBegin, Integer timestampEnd) throws RpcException {
    return transport.callForResult(new TypeReference<java.util.List<Location>>(){}, "get_locations", accountId, chatId, contactId, timestampBegin, timestampEnd);
  }

  public void sendWebxdcStatusUpdate(Integer accountId, Integer instanceMsgId, String updateStr, String description) throws RpcException {
    transport.call("send_webxdc_status_update", accountId, instanceMsgId, updateStr, description);
  }

  public void sendWebxdcRealtimeData(Integer accountId, Integer instanceMsgId, java.util.List<Integer> data) throws RpcException {
    transport.call("send_webxdc_realtime_data", accountId, instanceMsgId, data);
  }

  public void sendWebxdcRealtimeAdvertisement(Integer accountId, Integer instanceMsgId) throws RpcException {
    transport.call("send_webxdc_realtime_advertisement", accountId, instanceMsgId);
  }

  public void leaveWebxdcRealtime(Integer accountId, Integer instanceMessageId) throws RpcException {
    transport.call("leave_webxdc_realtime", accountId, instanceMessageId);
  }

  public String getWebxdcStatusUpdates(Integer accountId, Integer instanceMsgId, Integer lastKnownSerial) throws RpcException {
    return transport.callForResult(new TypeReference<String>(){}, "get_webxdc_status_updates", accountId, instanceMsgId, lastKnownSerial);
  }

  /* Get info from a webxdc message */
  public WebxdcMessageInfo getWebxdcInfo(Integer accountId, Integer instanceMsgId) throws RpcException {
    return transport.callForResult(new TypeReference<WebxdcMessageInfo>(){}, "get_webxdc_info", accountId, instanceMsgId);
  }

  /**
   *  Get blob encoded as base64 from a webxdc message
   *
   *  path is the path of the file within webxdc archive
   */
  public String getWebxdcBlob(Integer accountId, Integer instanceMsgId, String path) throws RpcException {
    return transport.callForResult(new TypeReference<String>(){}, "get_webxdc_blob", accountId, instanceMsgId, path);
  }

  /**
   *  Sets Webxdc file as integration.
   *  `file` is the .xdc to use as Webxdc integration.
   */
  public void setWebxdcIntegration(Integer accountId, String filePath) throws RpcException {
    transport.call("set_webxdc_integration", accountId, filePath);
  }

  /**
   *  Returns Webxdc instance used for optional integrations.
   *  UI can open the Webxdc as usual.
   *  Returns `None` if there is no integration; the caller can add one using `set_webxdc_integration` then.
   *  `integrate_for` is the chat to get the integration for.
   */
  public Integer initWebxdcIntegration(Integer accountId, Integer chatId) throws RpcException {
    return transport.callForResult(new TypeReference<Integer>(){}, "init_webxdc_integration", accountId, chatId);
  }

  /**
   *  Makes an HTTP GET request and returns a response.
   *
   *  `url` is the HTTP or HTTPS URL.
   */
  public HttpResponse getHttpResponse(Integer accountId, String url) throws RpcException {
    return transport.callForResult(new TypeReference<HttpResponse>(){}, "get_http_response", accountId, url);
  }

  /**
   *  Forward messages to another chat.
   *
   *  All types of messages can be forwarded,
   *  however, they will be flagged as such (dc_msg_is_forwarded() is set).
   *
   *  Original sender, info-state and webxdc updates are not forwarded on purpose.
   */
  public void forwardMessages(Integer accountId, java.util.List<Integer> messageIds, Integer chatId) throws RpcException {
    transport.call("forward_messages", accountId, messageIds, chatId);
  }

  /**
   *  Resend messages and make information available for newly added chat members.
   *  Resending sends out the original message, however, recipients and webxdc-status may differ.
   *  Clients that already have the original message can still ignore the resent message as
   *  they have tracked the state by dedicated updates.
   *
   *  Some messages cannot be resent, eg. info-messages, drafts, already pending messages or messages that are not sent by SELF.
   *
   *  message_ids all message IDs that should be resend. All messages must belong to the same chat.
   */
  public void resendMessages(Integer accountId, java.util.List<Integer> messageIds) throws RpcException {
    transport.call("resend_messages", accountId, messageIds);
  }

  public Integer sendSticker(Integer accountId, Integer chatId, String stickerPath) throws RpcException {
    return transport.callForResult(new TypeReference<Integer>(){}, "send_sticker", accountId, chatId, stickerPath);
  }

  /**
   *  Send a reaction to message.
   *
   *  Reaction is a string of emojis separated by spaces. Reaction to a
   *  single message can be sent multiple times. The last reaction
   *  received overrides all previously received reactions. It is
   *  possible to remove all reactions by sending an empty string.
   */
  public Integer sendReaction(Integer accountId, Integer messageId, java.util.List<String> reaction) throws RpcException {
    return transport.callForResult(new TypeReference<Integer>(){}, "send_reaction", accountId, messageId, reaction);
  }

  /* Returns reactions to the message. */
  public Reactions getMessageReactions(Integer accountId, Integer messageId) throws RpcException {
    return transport.callForResult(new TypeReference<Reactions>(){}, "get_message_reactions", accountId, messageId);
  }

  public Integer sendMsg(Integer accountId, Integer chatId, MessageData data) throws RpcException {
    return transport.callForResult(new TypeReference<Integer>(){}, "send_msg", accountId, chatId, data);
  }

  /* Checks if messages can be sent to a given chat. */
  public Boolean canSend(Integer accountId, Integer chatId) throws RpcException {
    return transport.callForResult(new TypeReference<Boolean>(){}, "can_send", accountId, chatId);
  }

  /**
   *  Saves a file copy at the user-provided path.
   *
   *  Fails if file already exists at the provided path.
   */
  public void saveMsgFile(Integer accountId, Integer msgId, String path) throws RpcException {
    transport.call("save_msg_file", accountId, msgId, path);
  }

  public void removeDraft(Integer accountId, Integer chatId) throws RpcException {
    transport.call("remove_draft", accountId, chatId);
  }

  /* Get draft for a chat, if any. */
  public Message getDraft(Integer accountId, Integer chatId) throws RpcException {
    return transport.callForResult(new TypeReference<Message>(){}, "get_draft", accountId, chatId);
  }

  public Integer sendVideochatInvitation(Integer accountId, Integer chatId) throws RpcException {
    return transport.callForResult(new TypeReference<Integer>(){}, "send_videochat_invitation", accountId, chatId);
  }

  public String miscGetStickerFolder(Integer accountId) throws RpcException {
    return transport.callForResult(new TypeReference<String>(){}, "misc_get_sticker_folder", accountId);
  }

  /* Saves a sticker to a collection/folder in the account's sticker folder. */
  public void miscSaveSticker(Integer accountId, Integer msgId, String collection) throws RpcException {
    transport.call("misc_save_sticker", accountId, msgId, collection);
  }

  /**
   *  for desktop, get stickers from stickers folder,
   *  grouped by the collection/folder they are in.
   */
  public java.util.Map<String, java.util.List<String>> miscGetStickers(Integer accountId) throws RpcException {
    return transport.callForResult(new TypeReference<java.util.Map<String, java.util.List<String>>>(){}, "misc_get_stickers", accountId);
  }

  /* Returns the messageid of the sent message */
  public Integer miscSendTextMessage(Integer accountId, Integer chatId, String text) throws RpcException {
    return transport.callForResult(new TypeReference<Integer>(){}, "misc_send_text_message", accountId, chatId, text);
  }

  public Pair<Integer, Message> miscSendMsg(Integer accountId, Integer chatId, String text, String file, Pair<Float, Float> location, Integer quotedMessageId) throws RpcException {
    return transport.callForResult(new TypeReference<Pair<Integer, Message>>(){}, "misc_send_msg", accountId, chatId, text, file, location, quotedMessageId);
  }

  public void miscSetDraft(Integer accountId, Integer chatId, String text, String file, Integer quotedMessageId, Viewtype viewType) throws RpcException {
    transport.call("misc_set_draft", accountId, chatId, text, file, quotedMessageId, viewType);
  }

  public Integer miscSendDraft(Integer accountId, Integer chatId) throws RpcException {
    return transport.callForResult(new TypeReference<Integer>(){}, "misc_send_draft", accountId, chatId);
  }

}