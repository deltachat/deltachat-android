<!DOCTYPE html>
<html>
  <head>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
      }
      .iframe-container {
        overflow: hidden;
        height: 100vh;
        width: 100vw;
        position: relative;
      }
      .iframe-container iframe {
        border: 0;
        height: 100%;
        left: 0;
        position: absolute;
        top: 0;
        width: 100%;
      }
      #progress {
        width: 100%;
      }
    </style>
  </head>
  <body>
    <div id="loading">
      <progress id="progress" max="100" value="0"></progress>
    </div>
    <div class="iframe-container">
      <iframe id="frame"></iframe>
    </div>
    <iframe id="test-isolated-sandbox-context" style="display: none"></iframe>
    <script>
      const thisUnchangable = (async () => {
        const connections = [];
        const loadingProgress = document.getElementById("progress");
        const loadingDiv = document.getElementById("loading");
        const iframe = document.getElementById("frame");
        const isolatedContextTest = document.getElementById(
          "test-isolated-sandbox-context"
        );

        const cert = {
          certificates: [
            await RTCPeerConnection.generateCertificate({
              name: "ECDSA",
              namedCurve: "P-256",
            }),
          ],
        };

        console.log("WEBRTC-WG: allocating");
        loadingProgress.value = 0;
        while (connections.length < 500) {
          try {
            connections.push(new RTCPeerConnection(cert));
            if (connections.length%50 == 0) {
              loadingProgress.value++;
              await new Promise((res) => setTimeout(res));
            }
          } catch (error) {
            loadingProgress.value++;
            new Array(1024*1024).fill(0);
            await new Promise((res) => setTimeout(res, 500));
            console.log("WEBRTC-WG: waiting for gc");
          }
        }
        console.log("WEBRTC-WG: done");

        try {
          /*
          for (let i = 0; i < 50; i++) {
            connections.push(new RTCPeerConnection(cert));
            connections.push(new RTCPeerConnection(cert));
            connections.push(new RTCPeerConnection(cert));
            connections.push(new RTCPeerConnection(cert));
            connections.push(new RTCPeerConnection(cert));
            connections.push(new RTCPeerConnection(cert));
            connections.push(new RTCPeerConnection(cert));
            connections.push(new RTCPeerConnection(cert));
            connections.push(new RTCPeerConnection(cert));
            connections.push(new RTCPeerConnection(cert));
            loadingProgress.value = i;
            await new Promise((res) => setTimeout(res));
          }
          */
          try {
            connections.push(new RTCPeerConnection());
            console.log("Error: was able to create more than 500 connections");
            loadingDiv.innerText =
              "Error: was not able to block webrtc ERROR_A";
          } catch (error) {
            try {
              new isolatedContextTest.contentWindow.RTCPeerConnection();
              console.log(
                "Error: was able to create more than 500 connections, iframe is probably isolated"
              );
              loadingDiv.innerText =
                "Error: was not able to block webrtc ERROR_C";
            } catch (error) {
              loadingDiv.innerHTML = "";
              iframe.src = "index.html";
              iframe.contentWindow.webxdc_internal = window.webxdc_internal;
              iframe.contentWindow.webxdc = window.webxdc;
            }
          }
        } catch (error) {
          console.log(
            "error loading, should crash / close webxdc activity",
            error
          );
          loadingDiv.innerText = "Error: was not able to block webrtc ERROR_B";
        }

        return Object.freeze({
          len: () => {
            return connections.length;
          },
        });
      })();
    </script>
  </body>
</html>
